#!/usr/bin/env python3
"""
# fastread #

Simple CLI application for plaintext speedreading.
"""

import argparse
import collections
import curses
import enum
import os
import signal
import sys
import time

__version__ = '0.2.2'
prog = os.path.basename(sys.argv[0])


def main():
    """ entrypoint """
    args = parse_args()
    wordbuf = WordBuffer(args.filename, args.skip)
    curses.wrapper(FastRead(args.wpm, wordbuf).run)


def parse_args():
    """ Parse command-line arguments """
    parser = argparse.ArgumentParser(prog=prog)

    def readable_filename(string):
        try:
            open(string).close()
        except OSError as exc:
            raise argparse.ArgumentTypeError(exc)
        else:
            return string

    parser.add_argument('filename', type=readable_filename,
                                    metavar='FILENAME',
                                    help='Input filename (default: stdin)')
    parser.add_argument('-w', '--wpm', default=500,
                                       type=int,
                                       metavar='WPM',
                                       help='set reading speed (in wpm)')
    parser.add_argument('-s', '--skip', default=0,
                                        type=int,
                                        metavar='N',
                                        help='skip N words')
    parser.add_argument('--version', action='version',
                                     version=__version__)
    return parser.parse_args()


class WordBuffer:
    """ Simple word buffer with backwards seeking """
    def __init__(self, filename, skip=0):
        with open(filename) as input_file:
            self.words = self._flatten(map(str.split,
                                           input_file.read()
                                                     .split('\n')))
        self.idx = skip

    def _flatten(self, _list):
        """ Return flat list from nested while keeping order """
        # base case - _list is str
        if isinstance(_list, str):
            return [_list]

        # recursive step - _list is list
        _output_list = []
        for _item_sublist in map(self._flatten, _list):
            _output_list.extend(_item_sublist)
        return _output_list

    def progress(self):
        """ Return tuple (finished, total) """
        return self.idx, len(self.words)

    def next(self):
        """ Get next word """
        self.idx = min(self.idx + 1, len(self.words) - 1)
        return self.words[self.idx]

    def prev(self):
        """ Get previous word """
        self.idx = max(self.idx - 1, 0)
        return self.words[self.idx]


class FastRead:
    """ FastRead engine """
    def __init__(self, wpm, wordbuf):
        self.wpm = wpm
        self.wordbuf = wordbuf

        self._timeout = None
        self._paused = True
        self._last_input_time = time.monotonic()
        self._time_buffer = 0.0
        self._raw_input_values = set(map(lambda x: x.value, UserInput))

    def run(self, stdscr):
        """ Initialize ncurses and start FastReader loop """
        curses.start_color()
        curses.use_default_colors()
        curses.init_pair(1, curses.COLOR_RED, -1)
        curses.noecho()
        curses.cbreak()
        curses.curs_set(False)

        self.stdscr = stdscr
        self.set_timeout(abs(60 / self.wpm) if self.wpm else None)

        self._last_input = time.monotonic()
        user_input = UserInput.NONE

        word = '[ERROR]'

        while True:
            timeout = abs((60 / self.wpm) * (1 - self._time_buffer)) \
                      if self.wpm and not self._paused \
                      else None
            self.set_timeout(timeout)

            user_input = self.get_input()
            input_time = time.monotonic() 

            if timeout and not self._paused \
                       and input_time - self._last_input_time > timeout:

                word = self.wordbuf.next() if self.wpm > 0 else self.wordbuf.prev()
                self._last_input_time = time.monotonic()
                self._time_buffer = 0.0

                if timeout and word[-1] in '\'":,':
                    self._time_buffer -= 0.5
                elif timeout and word[-1] in '!?.':
                    self._time_buffer -= 1.

            elif timeout:
                elapsed = (input_time - self._last_input_time)
                self._time_buffer += elapsed/ abs(60 / self.wpm)
                self._last_input_time = input_time

            if user_input == UserInput.INCREASE:
                self.wpm = min(1000, self.wpm + 50)
            elif user_input == UserInput.DECREASE:
                self.wpm = max(-1000, self.wpm - 50)
            elif user_input == UserInput.PAUSE:
                self._paused = not self._paused
                self._time_buffer = 0
                self._last_input_time = time.monotonic()
            elif user_input == UserInput.NEXT:
                if self._paused:
                    word = self.wordbuf.next()
            elif user_input == UserInput.PREVIOUS:
                if self._paused:
                    word = self.wordbuf.prev()
            elif user_input == UserInput.QUIT:
                break

            self.update(word)

    def set_timeout(self, timeout):
        """ Update timeout from value of wpm """
        if self._timeout != (int(1000 * timeout) if timeout else -1):
            self._timeout = int(1000 * timeout) if timeout else -1
            self.stdscr.timeout(self._timeout)

    def update(self, word):
        """ Update screen with new word """
        self.stdscr.clear()
        max_row, max_col = self.stdscr.getmaxyx()
        row, col = max_row // 2, (max_col - len(word)) // 2

        red_idx = (len(word) - 1) // 2 if max_col % 2 == 0 else len(word) // 2
        finished, total = self.wordbuf.progress()
        PRECISION = 5
        percentage = int((10**PRECISION)*(finished / total)) / (10**PRECISION)

        self.stdscr.addstr(2, 3, 'WPM:       {}'.format(self.wpm))
        self.stdscr.addstr(3, 3, 'PROGRESS:  {}/{} [{}%]'.format(finished,
                                                                 total,
                                                                 percentage))

        if self._paused:
            self.stdscr.addstr(4, 3, '[PAUSED] -- press space to unpause',
                                     curses.color_pair(1))

        self.stdscr.addstr(row-1, col+red_idx, 'V', curses.color_pair(1))
        self.stdscr.addstr(row, col, word[:red_idx])
        self.stdscr.addstr(row, col+red_idx, word[red_idx], curses.color_pair(1))
        self.stdscr.addstr(row, col+red_idx+1, word[red_idx+1:])

        self.stdscr.refresh()

    def get_input(self):
        """ Wait for key with timeout """
        raw_user_input = self.stdscr.getch()
        if raw_user_input in self._raw_input_values:
            return UserInput(raw_user_input)
        return UserInput.NONE


class UserInput(enum.Enum):
    """ User input enumeration """
    INCREASE = ord('k')
    DECREASE = ord('j')
    PAUSE = ord(' ')
    NEXT = ord('l')
    PREVIOUS = ord('h')
    QUIT = ord('q')
    NONE = None


def signal_handler(*args, **kwargs):
    """ Treat SIGTERM as KeyboardInterrupt """
    raise KeyboardInterrupt
signal.signal(signal.SIGTERM, signal_handler)


if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print('Exit on KeyboardInterrupt...', file=sys.stderr)
